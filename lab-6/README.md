# A. Проверка сбалансированности
АВЛ-дерево является сбалансированным в следующем смысле: для любой вершины высота ее левого поддерева отличается от высоты ее правого поддерева не больше, чем на единицу.

Введем понятие баланса вершины: для вершины дерева $V$ ее баланс $B(V)$ равен разности высоты правого поддерева и высоты левого поддерева.

Таким образом, свойство АВЛ-дерева, приведенное выше, можно сормулировать следующим образом: для любой ее вершины $V$ выполняется следующее неравенство: $−1≤B(V)≤1$.

Дано двоичное дерево поиска. Для каждой его вершины требуется определить ее баланс.  

Входные данные  

Входные данные содержат описание двоичного дерева.  

В первой строке файла находится число $n (1≤n≤2⋅10^5)$ - число вершин в дереве. В последующих n строках файла находятся описания вершин дерева. В $(i+1)$-ой строке файла $(1≤i≤n)$ находится описание $i$-ой вершины, состоящее из трех чисел $K_{i}, L_{i}, R_{i}$, разделенных пробелами ключа в $i$-ой вершине $(∣K_{i}∣<=10^9)$, номера левого ребенка $i$-ой вершины $(i<L_{i}≤n)$ или $L_{i}=0$, если левого ребенка нет) и номера правого ребенка $i$-ой вершины $(i<R_{i}≤n)$ или $R_{i}=0$, если правого ребенка нет).  

Все ключи различны. Гарантируется, что данное дерево является деревом поиска.  

Выходные данные  

Для $i$-ой вершины в $i$-ой строке выведите одно число - баланс данной вершины.  

# B. Делаю я левый поворот
Для балансировки АВЛ-дерева при операциях вставки и удаления производятся левые и правые повороты. Левый поворот в вершине производится, когда баланс этой вершины больше 1, аналогично, правый поворот производится при балансе, меньшем 1.

Существует два разных левых (как, разумеется, и правых) поворота: большой и малый левый поворот.

Малый левый поворот осуществляется следующим образом:

{скоро тут будет иллюстрация}

Заметим, что если до выполнения малого левого поворота был нарушен баланс только корня дерева, то после его выполнения все вершины становятся сбалансированными, за исключением случая, когда у правого ребенка корня баланс до поворота равен 1. В этом случае вместо малого левого поворота выполняется большой левый поворот, который осуществляется так:

{скоро тут будет иллюстрация}

Дано дерево, в котором баланс дерева равен 2. Сделайте левый поворот.

Входные данные

Входные данные содержат описание двоичного дерева.

В первой строке файла находится число $n (1≤n≤2⋅10^5)$ - число вершин в дереве. В последующих $n$ строках файла находятся описания вершин дерева. В $(i+1)$-ой строке файла $(1≤i≤n)$ находится описание $i$-ой вершины, состоящее из трех чисел $K_{i}, R_{i}$, разделенных пробелами ключа в $i$-ой вершине $(∣K_{i}∣<=10^9)$, номера левого ребенка $i$-ой вершины $(i<L_{i}≤n)$ или $L_{i}=0$, если левого ребенка нет) и номера правого ребенка $i$-ой вершины $(i<R_{i}≤n)$ или $R_{i}=0$, если правого ребенка нет).  

Все ключи различны. Гарантируется, что данное дерево является деревом поиска. Все ключи различны. Баланс корня дерева (вершины с номером 1) равен 2, баланс всех остальных вершин находится в пределах от -1 до 1.

Выходные данные

Выведите в том же формате дерево после осуществления левого поворота. Нумерация вершин может быть произвольной при условии соблюдения формата. Так, номер вершины должен быть меньше номера ее детей.

# C. Вставка в АВЛ-дерево
Вставка в АВЛ-дерево вершины $V$ с ключом $X$ при условии, что такой вершины в этом дереве нет, осуществляется следующим образом:  

* находится вершина $W$, ребенком которой должна стать вершина $V$;  

* вершина $V$ делается ребенком вершины $W$;  

* производится подъем от вершины $W$ к корню, при этом, если какая-то из вершин несбалансирована, производится, в зависимости от значения баланса, левый или правый поворот.  

Первый этап нуждается в пояснении. Спуск до будущего родителя вершины V осуществляется, начиная от корня, следующим образом:

Пусть ключ текущей вершины равен $Y$.

* Если $X<Y$ и у текущей вершины есть левый ребенок, переходим к левому ребенку.

* Если $X<Y$ и у текущей вершины нет левого ребенка, то останавливаемся, текущая вершина будет родителем новой вершины.

* Если $X>Y$ и у текущей вершины есть правый ребенок, переходим к правому ребенку.

* Если $X>Y$ и у текущей вершины нет правого ребенка, то останавливаемся, текущая вершина будет родителем новой вершины.

Отдельно рассматривается следующий крайний случай если до вставки дерево было пустым, то вставка новой вершины осуществляется проще: новая вершина становится корнем дерева.

Входные данные

Входные данные содержат описание двоичного дерева.

В первой строке файла находится число $n (0≤n≤2⋅10^5)$ - число вершин в дереве. В последующих $n$ строках файла находятся описания вершин дерева. В $(i+1)$-ой строке файла $(1≤i≤n)$ находится описание $i$-ой вершины, состоящее из трех чисел $K_{i}, L_{i}, R_{i}$, разделенных пробелами ключа в $i$-ой вершине $(∣K_{i}∣<=10^9)$, номера левого ребенка $i$-ой вершины ($i<L_{i}≤n$ или $L_{i}=0$, если левого ребенка нет) и номера правого ребенка $i$-ой вершины ($i<R_{i}≤n$ или $R_{i}=0$, если правого ребенка нет).

Все ключи различны. Гарантируется, что данное дерево является корректным АВЛ-деревом.

В последней строке содержится число $X (∣X∣<=10^9)$ ключ вершины, которую требуется вставить в дерево. Гарантируется, что такой вершины в дереве нет.

Выходные данные

Выведите в том же формате дерево после осуществления левого поворота. Нумерация вершин может быть произвольной при условии соблюдения формата. Так, номер вершины должен быть меньше номера ее детей.

# D. Очистка телефона
У Пети в телефоне записаны номера друзей. Однажды Петя заметил, что у него кончается свободная память на устройстве. Петя знал, что среди его контактов есть множество дубликатов. Он решил удалить повторяющиеся записи.

Каждый контакт - это строка, состоящая исключительно из строчных или заглавных букв латинского алфавита и цифр. При удалении строки освобождается $M$ байт памяти, где $M$ - количество различных символов в данной строке. Помогите Пете узнать, сколько памяти в байтах он сможет освободить.

Входные данные

В первой строке входных данных дается число $n (1≤n≤10^5)$ - количество контактов в телефоне.

В следующей строке записаны через пробел $n$ строк $(1≤s_{i}≤10^4)$ - контакты Пети.

Выходные данные

Выведите одно число - ответ на задачу.


# E. Три друга 2: возвращение
Три друга списывают лабораторную работу, каждый из них списывает по 
n
n различных задач. Поскольку друзья не очень умные, они не меняют названия отправляемых на проверку файлов.

По истечении времени, отведенного на написание лабораторной, преподаватель запускает бан-машину и ставит баллы по следующим правилам:

если задача написана только у одного студента, то этот студент получает 3 балла, поскольку эту задачу он не списывал и не давал списывать;
если задача списана ровно у двух студентов, то каждый из них получает по 1 утешительному баллу;
если задача списана всеми тремя студентами, то за нее баллы не начисляются никому.
Выведите финальное количество баллов у каждого студента.

В рамках этой задачи будем считать, что Бан-машина считает решения списанными, если у них полностью совпадают имена файлов.

Входные данные

В первой строке входных данных дается число $n (1≤n≤100000)$ - количество задач в лабораторной.

Следующие три строки содержат по $n$ различных слов в каждой — названия файлов с решениями, отправленных каждым из студентов.

Выходные данные

Необходимо вывести 3 числа - количество баллов у первого, второго и третьего студента соответственно.

# F. Детектив
В городе $N$ произошла серия преступлений, расследовать которую пригласили опытного детектива Шерлока Толмса. Он с радостью принялся за новое интересное дело, но не учел, что в этот раз улик оказалось слишком много, и все они имеют совершенно разный "вес" для проведения расследовния.

Шерлок нашел в телефонной книжке номер самого талантливого программиста в городе, которым оказались Вы, и обратился за помощью. Обладая знаниями алгоритмов и структур данных и проанализировав ситуацию, Вы решили хранить все зацепки в виде АВЛ-дерева, чтобы при необходимости достаточно быстро находить любой объект, при этом учитывая вес каждого свидетельства.

Во время расследования дела, Вам предстоит не только добавлять новые улики, но и удалять те, которые уже потеряли актуальность, а также проверять наличие определенных улик. К сожалению, не все знают как работает АВЛ-дерево, поэтому коллеги попросили Вас выводить баланс дерева после каждой операции вставки и удаления.

Входные данные

В первой строке находится число $n(1≤n≤2∗10^5)$ - число операций. Изначально улик нет. В каждой из последующих $n$ строк находится описание одной из трех операций:  

$A x$ - поместить улику с весом $x$ в дерево. Если она уже было добавлена, операция игнорируется   

$D x$ - удалить потерявшую актуальность улику, которое имеет вес $x$. Если такой нет, операция игнорируется.  

$C x$ - проверить наличие улики с весом $x$.  

Выходные данные

Для каждой операции вида $C x$ выведите $Y$, если такая улика содержится в дереве, и $N$, если не содержится.

Для каждой операции вида $A x$ или $D x$ выведите баланс корня дерева после выполнения операции.

Если дерево пустое (в нем нет вершин), выведите $0$.

Вывод для каждой операции должен содержаться на отдельной строке.